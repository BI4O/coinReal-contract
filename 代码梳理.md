# CoinReal的代码梳理

## 用户管理模块UserManager

### User

| 字段名       | 类型      | 说明         |
| ------------ | --------- | ------------ |
| address    | address | 地址         |
| id         | uint    | 用户id       |
| name       | string  | 用户名称     |
| bio        | string  | 用户简介     |
| email      | string  | 用户邮箱     |
| registered | bool    | 是否已注册   |

### 增

##### um.\_registerUser(user, name, bio, email) 

只有user、name、bio、email是必须的

- id自动递增
- register自动为true

```solidity
// 增：用户注册
function _registerUser(
    address _user,
    string memory _name, 
    string memory _bio, 
    string memory _email
) public {
    require(!users[_user].registered, "User already registered");
    users[_user] = User({
        id: nextUserId,
        name: _name,
        bio: _bio,
        email: _email,
        registered: true
    });
    usersById[nextUserId] = _user;
    nextUserId++;
}
```

### 查

##### um._getUser(address _user) => User

```solidity
function _getUser(address _user) public view returns (User memory) {
    return users[_user];
}
```

##### um._getUserById(uint _id) => User

```solidity
function _getUserById(uint _id) public view returns (User memory) {
    return users[usersById[_id]];
}
```

### 改

##### um._updateUser(user,name,bio,email)

```solidity
function _updateUser(
    address _user,
    string memory _name, 
    string memory _bio, 
    string memory _email
) 
```

### 删

##### um._deleteUser(address _user)

```solidity
function _deleteUser(address _user) public {
    delete users[_user];
    delete usersById[users[_user].id];
}
```

## 话题管理模块（基础）

### Topic表

| 字段名       | 类型    | 描述          |
| ----------- | ------- | ------------- |
| id           | uint    | 项目id        |
| name | string  | 项目名称      |
| description | string  | 项目描述      |
| tokenAddress | string  | 项目token地址 |
| tokenPrice   | uint    | 项目token价格 |
| dataFeed     | address | 数据源地址    |
| commentCount | uint    | 评论数        |
| likeCount    | uint    | 点赞数        |

### 增

##### tm._registerTopic(name, description, tokenAddress, tokenPrice)

只有name、desc、tokenAddr、tokenPrice是个必须

- id自动
- dataFeed后续绑定
- commentCount外部联动才增加的
- likeCount外部联动才增加的

```solidity
function _registerTopic(
    string memory _name, 
    string memory _description, 
    string memory _tokenAddress,
    uint _tokenPrice
) public {
    topics[nextTopicId] = Topic({
        id: nextTopicId,
        name: _name,
        description: _description,
        tokenAddress: _tokenAddress,
        tokenPrice: _tokenPrice,  // 初始化价格
        dataFeed: address(0), // 默认数据源地址为0
        commentCount: 0,
        likeCount: 0
    });
    // 话题名称不能为空
    require(bytes(topics[nextTopicId].name).length > 0, "Topic name is empty");
    topicsByTokenAddress[_tokenAddress] = topics[nextTopicId];
    nextTopicId++;
}
```

### 查

##### tm._getTopic(uint _topicId) => Topic

```solidity
// 查：根据id获取话题
function _getTopic(uint _topicId) public view returns (Topic memory) {
    return topics[_topicId];
}
```

##### tm._getTopicByTokenAddress(tokenAddress) => Topic

```solidity
// 查：根据tokenAddress获取话题
function _getTopicByTokenAddress(string memory _tokenAddress) public view returns (Topic memory) {
    return topicsByTokenAddress[_tokenAddress];
}
```

##### tm.listTopics() => Topic[]

```solidity
// 查：列出所有话题
function listTopics() public view returns (Topic[] memory) {
    Topic[] memory topicsList = new Topic[](nextTopicId);
    for (uint i = 0; i < nextTopicId; i++) {
        topicsList[i] = topics[i];
    }
    return topicsList;
}
```

### 改

目前只能修改价格，或者删掉重新创建

##### tm.\_updateTopicTokenPrice(uint \_topicId, uint \_tokenPrice)

```solidity
// 改：手动更新话题的token价格
function _updateTopicTokenPrice(uint _topicId, uint _tokenPrice) public {
    // 如果已经删除了，则name为空，不允许更新价格
    require(bytes(topics[_topicId].name).length > 0, "Topic not exist");
    topics[_topicId].tokenPrice = _tokenPrice;
}

// 改：自动更新话题的token价格 TODO chainlink-datafeed
function _updateTopicTokenPriceAuto(uint _topicId) public {
    // 如果已经删除了，则name为空，不允许更新价格
    require(bytes(topics[_topicId].name).length > 0, "Topic not exist");

    // chainlink-datafeed
    // 数据源地址不为0
    require(topics[_topicId].dataFeed != address(0), "Data feed not set");

    // TODO 后续改成用chainlink-datafeed获取价格
    topics[_topicId].tokenPrice = 0;
}
```

### 删

##### tm.\_deleteTopic(uint \_topicId)

```solidity
// 删：删除话题
function _deleteTopic(uint _topicId) public {
    delete topicsByTokenAddress[topics[_topicId].tokenAddress];
    delete topics[_topicId];        
}
```

## 话题管理模块（高级）

### CampaignInfo表

| 字段名                        | 数据类型 | 描述                                |
| ----------------------------- | -------- | ----------------------------------- |
| id                            | uint     | 活动id                              |
| **sponsor**                   | address  | 活动赞助商                          |
| **topicId**                   | uint     | 话题id：外键                        |
| **name**                      | string   | 活动名称                            |
| **description**               | string   | 活动描述                            |
| isActive                      | bool     | 活动是否激活                        |
| startTime                     | uint     | 活动开始时间                        |
| endTime                       | uint     | 活动结束时间                        |
| jackpot                       | uint     | 奖金池(美元计价)                    |
| mintTokenAmount               | uint     | 活动期间mint的token数量(decimal 18) |
| rewardUsdcPerMillionCPToken   | uint     | 每百万CP token的得USDC数            |
| rewardPtokenPerMillionCPToken | uint     | 每百万CP token的奖励                |

### 绑定说明

CampaignInfo，是通过topicId绑定在某个topic下面的，一个topic最多有3个进行中的campaignInfo

> [!important]
>
> 如果已知一个topicId，可以找到他关联的campaignInfo
>
> ##### topicCampaigns[topicId] => [campaignInfo1, campaignInfo2...]
>
> 通过这些找到的cid = campaignInfo.id，可以找到对应的campaignToken地址
>
> ##### campaigns[cid] => campaignTokenAddress

在新增Campaign前，有一些常量需要提前设置

- commentReward = 10 ether
- likeReward = 5 ether

### 增

##### tm._registerCampaign(sponsor, topicId, name, description) => (true, campaignId)

```solidity
function _registerCampaign(
    address _sponsor,
    uint _topicId,
    string memory _name,
    string memory _description
) public returns (bool, uint) {
    // 创建合约
    address campaignToken = campaignFactory.createCampaignToken(
        _name,
        string(abi.encodePacked(_name, "Token")),
        _topicId
    );
    // 建索引
    campaigns[nextCampaignId] = campaignToken;
    topicCampaigns[_topicId].push(nextCampaignId);

    // 插入一行新的数据
    campaignInfos[nextCampaignId] = CampaignInfo({
        id: nextCampaignId,                     // 活动id
        sponsor: _sponsor,                      // 活动赞助商
        topicId: _topicId,                      // 话题id
        name: _name,                            // 活动名称
        description: _description,              // 活动描述
        isActive: false,                        // 开始后转true，结束后再转false，活动是否激活
        startTime: 0,                           // 开始后记录：活动开始时间
        endTime: 0,                             // 开始后记录：活动结束时间
        jackpot: 0,                             // 开始后记录：活动奖金池
        mintTokenAmount: 0,                     // 结束后记录：活动期间mint的token数量
        rewardUsdcPerMillionCPToken: 0,         // 结束后记录：每百万CP token的得多少颗USDC
        rewardPtokenPerMillionCPToken: 0        // 结束后记录：每百万CP token的得多少颗项目方token
    });

    nextCampaignId++;
    return (true, nextCampaignId - 1);
}
```

> [!note]
>
> 增加完成之后，是一个ERC20的CampaignToken，需要通过token.start(uint _endTime)来启动，启动过程中会检查是否知否已经注资完成
>
> ```solidity
> // 活动开始前注资
> function fundProjectToken(uint256 amount) public {
>     projectToken.transferFrom(msg.sender, address(this), amount);
> }
> 
> // 活动开始前注资
> function fundUSDC(uint256 amount) public {
>     usdc.transferFrom(msg.sender, address(this), amount);
> }
> 
> // 活动开始前检查注资是否完成
> function checkFunding() public view returns(bool) {
>     // 需要注资USDC或者1.5倍于奖金美元价值的项目方token
>     uint256 usdcInUSD = usdc.balanceOf(address(this));
>     uint256 projectTokenInUSD = projectToken.balanceOf(address(this)) * projectToken.price();
> 
>     // 如果usdc注资额已经达到了minJackpot，直接返回通过
>     if (usdcInUSD >= minJackpot) {
>         return true;
>     // 如果不够，那么两者加起来必须要大于1.5倍于奖金美元价值的项目方token
>     } else {
>         return usdcInUSD + projectTokenInUSD >= minJackpot * 15 / 10;
>     }
> }
> ```
>
> 然后才可以开始活动

### 查

##### tm.\_getTopicCampaigns(topicId) => [campaignId1, campaignId2...]

根据topicId查下面有哪几个campaignign，用campaignId表示

```solidity
function _getTopicCampaigns(uint _topicId) public view returns (uint[] memory) {
    return topicCampaigns[_topicId];
}
```

##### tm._getCampaignInfo(campaignId) => campaignInfo

再根据这些campaignId找到对应的camapignInfo

```solidity
function _getCampaignInfo(uint _campaignId) public view returns (CampaignInfo memory) {
    return campaignInfos[_campaignId];
}
```

### 改：启动

##### tm.function \_startCampaign(uint \_campaignId, uint \_endTime)

> [!note]
>
> 但是这个函数运行之前要用check来检查
>
> ##### tm._checkCampaignCanStart(uint _campaignId) public view returns (bool)
>
> 如果不通过，说明还没有注资，可以用以下方式先注资
>
> ##### function _fundCampaignWithProjectToken(uint _campaignId, uint _amount) 
>
> ##### function _fundCampaignWithUSDC(uint _campaignId, uint _amount)

check通过之后，才可以开始这个活动

```solidity
// 改：活动开始
function _startCampaign(uint _campaignId, uint _endTime) public {
    require(_campaignId < nextCampaignId, "Campaign does not exist");
    require(_checkCampaignCanStart(_campaignId) == true, "Campaign funding is not enough");
    CampaignToken c = CampaignToken(campaigns[_campaignId]);

    // token的信息更新到campaignInfo中
    c.start(_endTime);
    // 更新四项信息
    campaignInfos[_campaignId].isActive = c.isActive();
    campaignInfos[_campaignId].startTime = c.startTime();
    campaignInfos[_campaignId].endTime = c.endTime();
    campaignInfos[_campaignId].jackpot = c.jackpotStart(); // 这里只是初始值，但是会浮动

    // 检查token的信息是否更新到campaignInfo中，如果没更新，则说明start失败
    require(campaignInfos[_campaignId].isActive == true, "Campaign start isActive didn't change");
}
```

### 改：结束

tm.

```solidity
// 活动结束
function _endCampaign(uint _campaignId) public {
    require(_campaignId < nextCampaignId, "Campaign does not exist");
    require(campaignInfos[_campaignId].isActive, "Campaign is not active");

    CampaignToken c = CampaignToken(campaigns[_campaignId]);

    // 尝试调用finish方法，如果失败，则尝试调用finishByLowTotalJackpot方法
    bool isFinished = c.finish();
    if (!isFinished) {
        isFinished = c.finishByLowTotalJackpot();
    }
    require(isFinished, "Campaign finish failed");

    // 更新结构体信息
    campaignInfos[_campaignId].isActive = c.isActive();
    campaignInfos[_campaignId].mintTokenAmount = c.totalSupply();
    campaignInfos[_campaignId].rewardUsdcPerMillionCPToken = c.usdcPerMillionCPToken();
    campaignInfos[_campaignId].rewardPtokenPerMillionCPToken = c.ptokenPerMillionCPToken();
    campaignInfos[_campaignId].jackpot = c.jackpotRealTime();
}
```

### 删

##### tm._deleteTopic(uint _topicId)

问AI：直接删除表里的信息可能会有问题，不知道怎么解决，应该直接设置一个isDeleted？

```solidity
// 删除活动
function _deleteTopic(uint _topicId) public {
    require(_topicId < nextTopicId, "Topic does not exist");
    require(_campaignId < nextCampaignId, "Campaign does not exist");

    // 删除topic
    _deleteTopicToken(_topicId);

    // 找到这些关联的campaignId
    uint[] memory campaignIds = topicCampaigns[_topicId];
    for (uint i = 0; i < campaignIds.length; i++) {
        // 删除campaign
        delete campaigns[campaignIds[i]];
        // 删除表里面这一行记录
        delete campaignInfos[campaignIds[i]];
    }
    // 删除topicCampaigns中的campaignId
    topicCampaigns[_topicId] = new uint[](0);       
}
```

## 动作管理模块

AcitonManager
